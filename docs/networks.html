---

title: Networks

keywords: fastai
sidebar: home_sidebar

summary: "Common neural network architectures for *Collaborative Filtering*."
description: "Common neural network architectures for *Collaborative Filtering*."
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: nbs/networks.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
    {% raw %}
        
<div class="cell border-box-sizing code_cell rendered">

</div>
<div class="cell border-box-sizing code_cell rendered">

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Overview">Overview<a class="anchor-link" href="#Overview">&#182;</a></h1><p>This package implements several neural network architectures that can be used to build recommendation systems. Users of the library can add or define their own implementations or use the existing ones. There are two layers that every architecture should define:</p>
<ul>
<li><strong>user_embeddings</strong>: The user embedding matrix</li>
<li><strong>item_embeddings</strong>: The item embedding matrix</li>
</ul>
<p>Every implementation should be a subclass of <code>torch.nn.Module</code>.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Simple-Collaborative-Filtering">Simple Collaborative Filtering<a class="anchor-link" href="#Simple-Collaborative-Filtering">&#182;</a></h2><p>This architecture is the simplest one to implement <em>Collaborative Filtering</em>. It only defines the embedding matrices for users and items and the final rating is computed by the dot product of the corresponding rows.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">

</div>
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="SimpleCF" class="doc_header"><code>class</code> <code>SimpleCF</code><a href="https://github.com/dpoulopoulos/cf_step/tree/master/cf_step/networks.py#L12" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>SimpleCF</code>(<strong><code>n_users</code></strong>:<code>int</code>, <strong><code>n_items</code></strong>:<code>int</code>, <strong><code>factors</code></strong>:<code>int</code>=<em><code>16</code></em>, <strong><code>user_embeddings</code></strong>:<code>tensor</code>=<em><code>None</code></em>, <strong><code>freeze_users</code></strong>:<code>bool</code>=<em><code>False</code></em>, <strong><code>item_embeddings</code></strong>:<code>tensor</code>=<em><code>None</code></em>, <strong><code>freeze_items</code></strong>:<code>bool</code>=<em><code>False</code></em>, <strong><code>init</code></strong>:<code>torch.nn.init</code>=<em><code>'normal_'</code></em>, <strong><code>binary</code></strong>:<code>bool</code>=<em><code>False</code></em>, <strong>**<code>kwargs</code></strong>) :: <code>Module</code></p>
</blockquote>
<p>Base class for all neural network modules.</p>
<p>Your models should also subclass this class.</p>
<p>Modules can also contain other Modules, allowing to nest them in
a tree structure. You can assign the submodules as regular attributes::</p>

<pre><code>import torch.nn as nn
import torch.nn.functional as F

class Model(nn.Module):
    def __init__(self):
        super(Model, self).__init__()
        self.conv1 = nn.Conv2d(1, 20, 5)
        self.conv2 = nn.Conv2d(20, 20, 5)

    def forward(self, x):
        x = F.relu(self.conv1(x))
        return F.relu(self.conv2(x))

</code></pre>
<p>Submodules assigned in this way will be registered, and will have their
parameters converted too when you call :meth:<code>to</code>, etc.</p>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Arguments:</p>
<ul>
<li>n_users (int): The number of unique users</li>
<li>n_items (int): The number of unique items</li>
<li>factors (int): The dimension of the embedding space</li>
<li>user_embeddings (torch.tensor): Pre-trained weights for the user embedding matrix</li>
<li>freeze_users (bool): <code>True</code> if we want to keep the user weights as is (i.e. non-trainable)</li>
<li>item_embeddings (torch.tensor): Pre-trained weights for the item embedding matrix</li>
<li>freeze_item (bool): <code>True</code> if we want to keep the item weights as is (i.e. non-trainable)</li>
<li>init (torch.nn.init): The initialization method of the embedding matrices - default: torch.nn.init.normal_</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># initialize the model with 100 users, 50 items and a 16-dimensional embedding space</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">SimpleCF</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="n">mean</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">std</span><span class="o">=.</span><span class="mi">1</span><span class="p">,</span> <span class="n">binary</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># predict the rating that user 3 would give to item 33</span>
<span class="n">model</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mi">2</span><span class="p">]),</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mi">32</span><span class="p">]))</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>tensor([[[0.5009]]], grad_fn=&lt;SigmoidBackward&gt;)</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}
</div>
 

